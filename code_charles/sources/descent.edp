/* Calculation of a descent direction from the gradient of the objective, without constraint */
include "./sources/inout.idp"
include "./sources/macros.idp"
load "msh3"

/* Get mesh and sol names, and global parameters */
string MESH       = getsParam(EXCHFILE,"MeshName");
string PHI        = getsParam(EXCHFILE,"PhiName");
string GRAD       = getsParam(EXCHFILE,"GradName");
string GRADJ      = getsParam(EXCHFILE,"GradJName");

/* Load mesh */
mesh3 Th = readmesh3(MESH);

/* Finite element spaces and functions */
fespace Vh(Th,P1);
fespace Vh0(Th,P0);
Vh g,gx,gy,gz,gJ,phi,nx,ny,nz,norm,v,vx,vy,vz;
Vh0 nx0,ny0,nz0,norm0;

/* Other parameters */
real eps = 1.e-6;
real ngmax;

loadsol(PHI,phi[]);
loadsol(GRADJ,gJ[]);
  
/* Extended normal vector as a P0 function over the mesh */
norm0 = sqrt(eps+dx(phi)*dx(phi)+dy(phi)*dy(phi)+dz(phi)*dz(phi));
nx0 = dx(phi) / norm0;
ny0 = dy(phi) / norm0;
nz0 = dz(phi) / norm0;

/* Scalar descent direction */
g = - gJ;
  
/* Conversion into a vector descent direction */
/* Extended normal vector as a P1 function over the mesh */
problem extnx(nx,v,solver=CG) = int3d(Th)(nx*v)
                      - int3d(Th)(nx0*v);

problem extny(ny,v,solver=CG) = int3d(Th)(ny*v)
                        - int3d(Th)(ny0*v);

problem extnz(nz,v,solver=CG) = int3d(Th)(nz*v)
                        - int3d(Th)(nz0*v);

extnx;
extny;
extnz;

norm = sqrt(eps^2+nx*nx+ny*ny+nz*nz);
nx = nx / norm;
ny = ny / norm;
nz = nz / norm;

/* Descent direction as a vector field along the normal direction */
gx = g * nx;
gy = g * ny;
gz = g * nz;

/* Save solution */
printvec3(GRAD,gx[],gy[],gz[]);

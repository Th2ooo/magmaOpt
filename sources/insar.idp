// include "./sources/inout.idp"
// include "./sources/macros.idp"


/* Get Insar data parameters */
string tck1       = getsParam(EXCHFILE,"Track1");
string tck2        = getsParam(EXCHFILE,"Track2");
real inc1         = getrParam(EXCHFILE,"Incl1");
real inc2        = getrParam(EXCHFILE,"Incl2");
real hea1        = getrParam(EXCHFILE,"Head1");
real hea2      = getrParam(EXCHFILE,"Head2");


/*Conversion to LOS geometry track 1**/
macro UtoLOS1(ux,uy,uz) -cos(hea1)*sin(inc1)*ux + sin(hea1)*sin(inc1)*uy + cos(inc1)*uz // End of macro


/*Conversion to LOS geometry track 2**/
macro UtoLOS2(ux,uy,uz) -cos(hea2)*sin(inc2)*ux + sin(hea2)*sin(inc2)*uy + cos(inc2)*uz // End of macro

/*Compute integrand of objective function (for error)*/
func real jlos(real ux, real uy, real uz, real los1o, real los2o){
    if (abs(los1o)>=1.0 || abs(los2o)>=1.0){
        // cout << "no " <<endl;
        return 0.0; //if no data here, no supp error is added
    }
    else {

        real LOS1U  = UtoLOS1(ux,uy,uz);  //modelled LOS displacement
        real LOS2U  = UtoLOS2(ux,uy,uz);
        // if (abs(los1o)>=0.01){
        cout << "LOS1U " << LOS1U <<" los1o "<<los1o << " los2o "<<los2o <<endl;
        // }
        return (LOS1U-los1o)^2+(LOS2U-los2o)^2 ;
    }

}

/*Compute part of the derivative of integrand of objective function (for adjoint state)*/
func real djlosdu1(real ux, real uy, real uz, real los1o){
    if (abs(los1o)>=1.0){
        return 0.0; //if no data here, no supp error is added
    }
    else {
        real LOS1U  = UtoLOS1(ux,uy,uz);  //modelled LOS displacement
        return 2.0*(LOS1U-los1o) ;
    }
}

func real djlosdu2(real ux, real uy, real uz, real los2o){
    if (abs(los2o)>=1.0){
        return 0.0; //if no data here, no supp error is added
    }
    else {
        real LOS2U  = UtoLOS2(ux,uy,uz);
        return 2.0*(LOS2U-los2o) ;
    }
}



// cout << "LOS1" << UtoLOS2(1,1,1) << endl ;




/////////////////////OLD VERSION OF INSAR FUCNTION, TOO SLOW\\\\\\\\\\\\\\\\\\\\\\\\\
// /*Local origin of the InSAR tracks (Lower left corner of InSAR tracks)*/
// real inX0 = 2532108.002;
// real inY0 = 180718.943;
//
// /*InSAR size*/
// int ncol = 216;
// int nrow = 176;
// real xrange = 21600.0 ;
// real yrange = 17600.0 ;
//
// /*Origin of the model in the InSAR track (midle)*/
// real modX0 = xrange/2 ;
// real modY0 = yrange/2 ;
//
//
// /*InSAR time coverage (bc input file is speed)*/
// real dt = 0.1479;
//
// /*Get coordinates from the mesh, compute grid position, and return the line in the raster xyz file*/
// func int getli(real xc, real yc) {
//
//     // i,j position in raster grid
//     real i=xc*(ncol-1)/xrange;
//     real j= (nrow-1)*(1-yc/yrange);  //bc xyz file make y direction decaying
//     //final line in xyz file
//     int line =  int(i+j*ncol+1);
//
//     return line ;
// }
//
//
//
// /*Get InSAR data at position x,y*/
// func real getLOS(real xc, real yc, string file){
//
//     // Solution with commands but doesnt work bc impossible to get output
//     // int cline = exec("sed '"+pos+"d;q' "+ file);
//     // real LOS = exec("echo '"+cline+"' | cut -d' ' -f3") ;
//
//     int pos = getli(xc,yc);
//     // cout << "LOS at line "<< pos << endl;
//     real LOS ;
//
//     ifstream ff(file) ; //open read file stream
//     int cpos =1 ; //initalize current postion in file
//     string line ; //current line
//
//     while (ff.good()&& cpos!=pos ) { //while file is open and pos not reached
//         getline(ff, line); //jump line
//         cpos ++ ; //increase line count
//     }
//     //Now we found the right line
//     ff >> LOS;//skip x
//     ff >> LOS;//skip y
//     ff >> LOS;//LOS
//     if (LOS == -99.0){
//         return -99.0; //no data here
//     }
//     else {
//         return LOS*dt*0.001; //displacement and m conversion
//     }
// }



#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri May 24 00:24:58 2024

@author: th2o
"""
import os
import gmsh 
import subprocess


from sources.utils import Extent

import sources.path as path


def build_mesh(out,ext=[],psrc=[],rads=[],vizu=False,basic=True,verb=3,debug=0) :
    """
    Build initial mesh with magma chamber

    Parameters
    ----------
    out : string
        output file where the mesh is written (has to be .mesh to be compatible with freefem/mmg)
    ext : list of floats, optional
        extent of the domain (X,Y,Z direction). If not provided, values from path are used.
    psrc : list of floats, optional
        position of the source (X,Y,Z direction). If not provided, values from path are used
    rads : list of floats, optional
        radii of the source (X,Y,Z direction). If not provided, values from path are used
    vizu : bool, optional
        Triigers gmsh gui to vizualize the mesh and model. The default is False.
    basic : bool, optional
        basic meshing mode = uniform. if false, a coarser mesh is defined far from the source. The default is True.
    verb : bool, optional
        verboisity level of gmsh outputs. The default is 3.
    debug : bool, optional
        If true, plots and outputs additional steps for debugging purpose. The default is 0.

    Returns
    -------
    None.

    """
   
    ####Paramters
    if not ext :
        ext = [path.XEXT,path.YEXT,path.ZEXT]
    if not psrc :
        psrc = [path.XS,path.YS,path.ZS]
    if not rads :
        rads = [path.REX,path.REY,path.REZ]
    xs = psrc[0]
    ys = psrc[1]
    zs = psrc[2]

    rx = rads[0] #semi axes ellipsoif
    ry = rads[1]
    rz = rads[2]
    
    domex = Extent()
    domex.init_with_range(ext[0],ext[1],ext[2])
    if not basic :
        domex.enlarge([10e3,10e3,10e3])
        
    ####Intialization
    
    gmsh.initialize()
    gmsh.option.setNumber("General.Terminal", 1)  # Use terminal output instead of GUI
    gmsh.option.setNumber("General.Verbosity", verb)
    gmsh.model.add("magma_source_flat")
    
    mod = gmsh.model
    occ = mod.occ
    msh = mod.mesh
    
    ####Geometry
    
    # Intial dimTags for the box and the source
    volboxdt = (3,111)
    volsrcdt = (3,112)

    # add the box domain
    occ.addBox(domex.xmin, domex.ymin, domex.zmin,
               domex.xrange, domex.yrange, domex.zrange,tag=volboxdt[1])
    
    # add the source domain and stretch it to llatch the correct dimensionts
    occ.addSphere(xs, ys, zs, 1,tag=volsrcdt[1])
    occ.dilate([volsrcdt],xs,ys,zs,rx,ry,rz)
    
    if debug : 
        occ.synchronize()
        gmsh.fltk.run()

    # fragment the domain in 2 distincts subdomains, the interior of the source and the exterior
    (volsrcdt,volboxdt), _ = occ.fragment([volboxdt], [volsrcdt],removeObject=True, removeTool=True) 
    
    # remove anyduplicated entitires
    occ.removeAllDuplicates() 
    occ.synchronize()
    
    # get the identity of the generated surfaces
    surfsrcdt= mod.getBoundary([volsrcdt])[0]
    surfboxdts = mod.getBoundary([volboxdt])
    
    if debug :
        print("BBB",volsrcdt,volboxdt,surfsrcdt,surfboxdts)
        print("after generation",mod.getEntities())

    ## Retag with the correct labels according to pathfile    
    mod.setTag(2,12,path.REFDIR) #bottom surface = dirichlet boundary (blocked)
    mod.setTag(2,10,path.REFUP) #top surface = surface for error calculation
    mod.setTag(2,surfsrcdt[1],path.REFISO) #source surface = neumann surface = iso surface (loaded)
    mod.setTag(3,volboxdt[1],path.REFEXT) #interior of the domain = Text
    mod.setTag(3,volsrcdt[1],path.REFINT) #interior of the source = Tint

    if debug :
        print("FINAL tags",mod.getEntities())
        gmsh.fltk.run()



    
    ####Meshing
    
    if basic : #basic uniform mesh size
        msh.setSize(mod.getEntities(), path.MESHSIZ)
    else :   #inhomogeneous mesh size (DOESNT WORK WITH MMG)
        inex = Extent() #extent of the fine meshed part
        inex.init_with_range(path.XEXT,path.YEXT,path.ZEXT)
        tagBox = msh.field.add("Box")
        msh.field.setNumber(tagBox, "VIn",path.MESHSIZ)
        msh.field.setNumber(tagBox, "VOut", 3e3)
        msh.field.setNumber(tagBox, "XMin", inex.xmin)
        msh.field.setNumber(tagBox, "XMax", inex.xmax)
        msh.field.setNumber(tagBox, "YMin", inex.ymin)
        msh.field.setNumber(tagBox, "YMax", inex.ymax)
        msh.field.setNumber(tagBox, "ZMin", inex.zmin)
        msh.field.setNumber(tagBox, "ZMax", inex.zmax)
        msh.field.setNumber(tagBox, "Thickness", 2e3)
        msh.field.setAsBackgroundMesh(tagBox)
        gmsh.option.setNumber("Mesh.MeshSizeExtendFromBoundary", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromPoints", 0)
        gmsh.option.setNumber("Mesh.MeshSizeFromCurvature", 0)
        
    # generate the mesh
    msh.generate()
    
    # remove the elements attached to the extra curve on the source generated by occ (creates labels problems after)
    undesired_dt = [(1,14),(0,14),(0,9)]
    for dt in undesired_dt : 
        msh.removeElements(dt[0],dt[1])
    msh.reclassifyNodes()
        
    # launch gmsh UI to check mesh and model
    if vizu or debug : 
        gmsh.fltk.run()
        
        
        
    ####Saving
    
    if os.access(os.path.dirname(out), os.W_OK):     # Check if we can write to this location
        print(f'Writing mesh in {out}')
        gmsh.write(out)
    else:
        print("No write permission in this directory!")
    
    
    # Close gmsh
    gmsh.finalize()

    

    
    
    
    
    
def inimsh(mesh,ext=[],psrc=[],rads=[],vizu=False,basic=True,verb=3) :
  
    
    build_mesh(mesh,ext,psrc,rads,vizu,basic,verb)
    print("GMSH meshing done")


    # rename temporaly the mesh for the remeshing
    tmpf = mesh.replace(".mesh",".tmp.mesh")
    os.rename(mesh, tmpf)
    
    # Call to mmg3d for remeshing the background mesh
    log = open(path.LOGFILE,'a')

    # !!! no -nr option to detect the ridges and keep them for the future
    proc = subprocess.Popen([f"{path.MMG3D} -in {tmpf} -hmin {path.HMIN} -hmax {path.HMAX} -hausd {path.HAUSD} -hgrad {path.HGRAD} -out {tmpf} -rmc"],shell=True,stdout=log)

    proc.wait()
    log.close()
    
    if ( proc.returncode != 0 ) :
        raise Exception("MMG remeshing failed")
        return 0
    else :
        os.rename(tmpf,mesh) #rename to the correct name
        # print(os.listdir("./res/"))
        print("mmg remeshing done")
        return 1


      
if  __name__ == "__main__":
    
    build_mesh("./res/test.mesh",basic=1,debug=1)
    # inimsh("./res/test.mesh",1)

/* Calculation of the ERROR of the input structure */
include "./sources/inout.idp"
include "./sources/macros.idp"
load "msh3"
load "iovtk"


//// Parameters
/* Get mesh and sol names, and global parameters */
string MESH       = getsParam(EXCHFILE,"MeshName");
string SOL        = getsParam(EXCHFILE,"DispName");
int REFUP        = getiParam(EXCHFILE,"Refup");
string MESHI      = getsParam(EXCHFILE,"ObjMesh"); //mesh on which insar data is interpolated
int ntck        = getiParam(EXCHFILE,"Ntracks");
real err, w;
string TMPLOS, TMPK;
/* Loading current mesh and insar data mesh*/
mesh3 Th = readmesh3(MESH);
mesh3 ThI = readmesh3(MESHI);

//arrays of InSAR parameters
real[int] heas(ntck), incs(ntck), ws(ntck) ;
for (int i = 0; i < ntck; ++i){
    incs[i] = getrParam(EXCHFILE,"Incl"+i);
    heas[i] = getrParam(EXCHFILE,"Head"+i);
    ws[i] = getrParam(EXCHFILE,"Weight"+i);
}
// LOS geometry conversion
macro UtoLOSi(ux,uy,uz,i) (-cos(heas[i])*sin(incs[i])*ux + sin(heas[i])*sin(incs[i])*uy + cos(incs[i])*uz) // End of macro



/* Finite element spaces and functions */
fespace Vh(Th,P1); //Current mesh fespace
Vh ux,uy,uz,tmplosp,tmpkp,ulosi,errfield;
Vh[int] losdatA(ntck), kdatA(ntck); // fespace array to contain the tracks interpolated on current mesh

fespace VhI(ThI,P1); //Mesh of insar data fespace
VhI tmplos, tmpk ; //tmp vars to load data


/* Read current displaement */
loadvec3(SOL,ux[],uy[],uz[]);


/* Loop over the different data tracks for interpolation */
for (int i = 0; i < ntck; ++i){
    cout << "Interpolating Track"+i << endl;
    TMPLOS       = getsParam(EXCHFILE,"Track"+i);
    TMPK        = getsParam(EXCHFILE,"K"+i);
    loadsol(TMPLOS,tmplos[]); //read insar data
    loadsol(TMPK,tmpk[]) ;
    tmplosp = tmplos ; // project it on the current mesh
    tmpkp = tmpk ;
    losdatA[i] = tmplosp; //save it in the array
    kdatA[i] = tmpkp ;
}


/*Compute error function for N tracks*/
err = 0.0 ;
for (int i = 0; i < ntck; ++i){
    cout << "Error Track"+i << endl;
    err = err + ws[i]*int2d(Th,REFUP)(kdatA[i]*(UtoLOSi(ux,uy,uz,i)-losdatA[i])^2);
    // errfield = errfield +  ws[i]*kdatA[i]*(UtoLOSi(ux,uy,uz,i)-losdatA[i])^2;  //error field for debugging
    // if (i==5){errfield=ws[i]*kdatA[i]*(UtoLOSi(ux,uy,uz,i)-losdatA[i])^2;}
}


/* Save result */
setrParam(EXCHFILE,"Error",err);
cout << "ERROR : " << err << endl ;



/*VTK output of the LOS for vizu*/
// for (int i = 0; i < ntck; ++i){
//     savevtk("losobj"+i+".vtu", Th,losdatA[i]); // data
//     ulosi = UtoLOSi(ux,uy,uz,i);
//     savevtk("losu"+i+".vtu",Th,ulosi);  // current LOS disp
// }
// savevtk("err2.vtu",Th,errfield) ;

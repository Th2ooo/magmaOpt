/* Calculation of the adjoint state for the stress functional */
include "./sources/inout.idp"
include "./sources/macros.idp"
load "medit"
load "msh3"
load "iovtk"

/* Get mesh and sol names, define global parameters */
string MESH       = getsParam(EXCHFILE,"MeshName");
string SOL        = getsParam(EXCHFILE,"DispName");
string ADJ        = getsParam(EXCHFILE,"AdjName");
int REFEXT          = getiParam(EXCHFILE,"Refext");
int REFDIR        = getiParam(EXCHFILE,"Dirichlet");
int REFUP        = getiParam(EXCHFILE,"Refup");

string MESHI      = getsParam(EXCHFILE,"ObjMesh"); //mesh on which insar data is interpolated
int ntck        = getiParam(EXCHFILE,"Ntracks");
string TMPLOS;

//arrays of InSAR parameters
real[int] heas(ntck), incs(ntck), ws(ntck) ;
for (int i = 0; i < ntck; ++i){
    incs[i] = getrParam(EXCHFILE,"Incl"+i);
    heas[i] = getrParam(EXCHFILE,"Head"+i);
    ws[i] = getrParam(EXCHFILE,"Weight"+i);
}
// LOS geometry conversion, i being the index of the insar track
macro UtoLOSi(ux,uy,uz,i) (-cos(heas[i])*sin(incs[i])*ux + sin(heas[i])*sin(incs[i])*uy + cos(incs[i])*uz) // End of macro


/* Loading current mesh and insar data mesh*/
mesh3 Th = readmesh3(MESH);
mesh3 ThI = readmesh3(MESHI);

/* Finite element spaces and functions */
fespace Vh(Th,P1);
fespace Vh0(Th,P0);
Vh ux,uy,uz,px,py,pz;
Vh0 reg = region;

fespace VhI(ThI,P1); //Mesh of insar data fespace
VhI tmplosi ; //tmplos los disp to load data

/* Read current displacement */
loadvec3(SOL,ux[],uy[],uz[]);


/* Mesh of the interior part and corresponding FE space */
mesh3 The = trunc(Th,(reg(x,y,z) == REFEXT),label=REFEXT);
fespace Vhe(The,P1);
Vhe uex,uey,uez,pex,pey,pez,vex,vey,vez,tmplosp;
Vhe[int] losdatA(ntck); // fespace array to contain the tracks interpolated on current mesh


/* Interpolation of displacement from full to sub mesh */
uex = ux;
uey = uy;
uez = uz;



/* Loop over the different data tracks for interpolation */
for (int i = 0; i < ntck; ++i){
    cout << "Interpolating Track"+i << endl;
    TMPLOS = getsParam(EXCHFILE,"Track"+i);
    loadsol(TMPLOS,tmplosi[]); //read insar data
    tmplosp = tmplosi ; // project it on the current mesh
    losdatA[i] = tmplosp; //save it in the array
}

/*Function computing the term product with v in integral adjoint top surface*/
func real sumbound(real ux, real uy, real uz, int comp){
    real out = 0.0 ;
    for (int i = 0; i < ntck; ++i){
        real s = ws[i]*(UtoLOSi(ux,uy,uz,i)-losdatA[i]); //term i of the sum
        // multiplication by the LOS vector, depending on the component
        if (comp==0){s=s*UtoLOSi(1,0,0,i);}
        if (comp==1){s=s*UtoLOSi(0,1,0,i);}
        if (comp==2){s=s*UtoLOSi(0,0,1,i);}
        out = out+s;
    }
    return out ;
}


/* Variational formulation of the problem */
problem adjoint([pex,pey,pez],[vex,vey,vez],solver=CG) = int3d(The)(2.0*mu*(dx(pex)*dx(vex)+dy(pey)*dy(vey)+dz(pez)*dz(vez)))
                                   + int3d(The)(mu*((dx(pey)+dy(pex))*(dx(vey)+dy(vex)) + (dx(pez)+dz(pex))*(dx(vez)+dz(vex)) + (dy(pez)+dz(pey))*(dy(vez)+dz(vey))))
                                   + int3d(The)(lm*(dx(pex)+dy(pey)+dz(pez))*(dx(vex)+dy(vey)+dz(vez)))
                                   + int2d(The,REFUP)(2.0*(vez*sumbound(uex,uey,uez,2)+vey*sumbound(uex,uey,uez,1)+vex*sumbound(uex,uey,uez,0)))
                                   + on(REFDIR,pex=0.0,pey=0.0,pez=0.0);



/* Solve problem */
adjoint;

/* Transfer the problem on the full mesh */
px = pex;
py = pey;
pz = pez;

/* Save solution */
printvec3(ADJ,px[],py[],pz[]);



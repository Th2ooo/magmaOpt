/* Calculation of a descent direction for the compliance minimization problem WITHOUT constraints */
include "./sources/inout.idp"
include "./sources/macros.idp"
load "msh3"
load "iovtk"

/* Get mesh and sol names, and global parameters */
string MESH       = getsParam(EXCHFILE,"MeshName");
string PHI        = getsParam(EXCHFILE,"PhiName");
string GRAD       = getsParam(EXCHFILE,"GradName");
string GRADE     = getsParam(EXCHFILE,"GradEName");

/* Scalar parameters */
real meshsize      = getrParam(EXCHFILE,"MeshSize");
real eps = 1.e-6;
real ndes ;


/* Load mesh */
mesh3 Th = readmesh3(MESH);

/* Finite element spaces and functions */
fespace Vh(Th,P1);
fespace Vh0(Th,P0);
Vh g,gx,gy,gz,thJ,phi,nx,ny,nz,norm,v,vx,vy,vz;
Vh0 nx0,ny0,nz0,norm0;
Vh0 reg = region;



loadsol(PHI,phi[]);
loadsol(GRADE,thJ[]);


/* Extended normal vector as a P0 function over the mesh */
norm0 = sqrt(eps+dx(phi)*dx(phi)+dy(phi)*dy(phi)+dz(phi)*dz(phi));
nx0 = dx(phi) / norm0;
ny0 = dy(phi) / norm0;
nz0 = dz(phi) / norm0;

/* Scalar descent direction */
ndes = max(-thJ[].min,thJ[].max); //norm L inf of the descent direction
g = - thJ*meshsize/(eps^2+ndes) ; // Scalar descent direction normalized to be about 1 mesh element long
  
/* Conversion into a vector descent direction */
/* Extended normal vector as a P1 function over the mesh */
problem extnx(nx,v,solver=CG) = int3d(Th)(nx*v)
                      - int3d(Th)(nx0*v);

problem extny(ny,v,solver=CG) = int3d(Th)(ny*v)
                        - int3d(Th)(ny0*v);

problem extnz(nz,v,solver=CG) = int3d(Th)(nz*v)
                        - int3d(Th)(nz0*v);

extnx;
extny;
extnz;

norm = sqrt(eps^2+nx*nx+ny*ny+nz*nz);
nx = nx / norm;
ny = ny / norm;
nz = nz / norm;

/* Descent direction as a vector field along the normal direction */
gx = g * nx;
gy = g * ny;
gz = g * nz;

/* Save solution */
printvec3(GRAD,gx[],gy[],gz[]);

// // VTU output for debuging
// savevtk("gvec.vtu", Th, [gx,gy,gz]);
